{"version":3,"file":"avalanche-js-account.cjs.production.min.js","sources":["../src/utils.ts","../src/account.ts","../src/wallet.ts","../src/hdnode.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module avalanche-account\n * @hidden\n */\n\nimport { HttpProvider, Messenger } from 'avalanche-js-network';\nimport { ChainType, ChainID } from 'avalanche-js-utils';\n\nexport const defaultMessenger = new Messenger(\n  new HttpProvider('http://localhost:9500'),\n  ChainType.Avalanche,\n  ChainID.HmyLocal,\n);\n","/**\n * @packageDocumentation\n * @module avalanche-account\n *\n */\n\nimport {\n  generatePrivateKey,\n  getAddressFromPrivateKey,\n  getPubkeyFromPrivateKey,\n  // toChecksumAddress,\n  encrypt,\n  decrypt,\n  EncryptOptions,\n  Keystore,\n  Signature,\n  getAddress,\n} from 'avalanche-js-crypto';\n\nimport {\n  isPrivateKey,\n  add0xToString,\n  hexToNumber,\n  AddressSuffix,\n  ChainType,\n} from 'avalanche-js-utils';\nimport { Transaction, RLPSign } from 'avalanche-js-transaction';\nimport { StakingTransaction } from 'avalanche-js-staking';\nimport { Messenger, RPCMethod } from 'avalanche-js-network';\nimport { Shards } from './types';\nimport { defaultMessenger } from './utils';\n\nexport interface Balance {\n  balance?: string;\n  nonce?: number;\n  shardID?: number;\n}\n\nclass Account {\n  /**\n   * static method create account\n   *\n   * @example\n   * ```javascript\n   * const account = new Account();\n   * console.log(account);\n   * ```\n   */\n  static new(): Account {\n    const newAcc = new Account()._new();\n    return newAcc;\n  }\n  /**\n   * Static Method: add a private key to Account\n   * @param  {string} key - private Key\n   *\n   * @example\n   * ```javascript\n   * const account = new Account.add(key_1);\n   * console.log(account);\n   * ```\n   */\n  static add(key: string): Account {\n    const newAcc = new Account()._import(key);\n    return newAcc;\n  }\n\n  /**@hidden */\n  privateKey?: string;\n  /**@hidden */\n  publicKey?: string;\n  /**@hidden */\n  address?: string;\n  /**@hidden */\n  balance?: string = '0';\n  /**@hidden */\n  nonce?: number = 0;\n  /**@hidden */\n  shardID: number;\n  /**@hidden */\n  shards: Shards;\n  /**@hidden */\n  messenger: Messenger;\n  /**@hidden */\n  encrypted: boolean = false;\n\n  /**\n   * check sum address\n   *\n   * @example\n   * ```javascript\n   * console.log(account.checksumAddress);\n   * ```\n   */\n  get checksumAddress(): string {\n    return this.address ? getAddress(this.address).checksum : '';\n  }\n\n  /**\n   * Get bech32 Address\n   *\n   * @example\n   * ```javascript\n   * console.log(account.bech32Address);\n   * ```\n   */\n  get bech32Address(): string {\n    return this.address ? getAddress(this.address).bech32 : '';\n  }\n\n  /**\n   * get Bech32 TestNet Address\n   *\n   * @example\n   * ```javascript\n   * console.log(account.bech32TestNetAddress);\n   * ```\n   */\n  get bech32TestNetAddress(): string {\n    return this.address ? getAddress(this.address).bech32TestNet : '';\n  }\n\n  /**\n   * get Shards number with this Account\n   *\n   * @example\n   * ```javascript\n   * console.log(account.getShardsCount);\n   * ```\n   */\n  get getShardsCount(): number {\n    return this.shards.size;\n  }\n\n  /**\n   * Generate an account object\n   *\n   * @param key import an existing privateKey, or create a random avax\n   * @param messenger you can setMessage later, or set message on `new`\n   *\n   * @example\n   * ```javascript\n   * // import the Account class\n   * const { Account } = require('avalanche-js-account');\n   *\n   * // Messenger is optional, by default, we have a defaultMessenger\n   * // If you like to change, you will import related package here.\n   * const { HttpProvider, Messenger } = require('avalanche-js-network');\n   * const { ChainType, ChainID } = require('avalanche-js-utils');\n   *\n   * // create a custom messenger\n   * const customMessenger = new Messenger(\n   *   new HttpProvider('http://localhost:9500'),\n   *   ChainType.Avalanche, // if you are connected to Avalanche's blockchain\n   *   ChainID.HmyLocal, // check if the chainId is correct\n   * )\n   *\n   * // setMessenger later\n   * const randomAccount = new Account()\n   * randomAccount.setMessenger(customMessenger)\n   *\n   * // or you can set messenger on `new`\n   * const randomAccountWithCustomMessenger = new Account(undefined, customMessenger)\n   *\n   * // NOTED: Key with or without `0x` are accepted, makes no different\n   * // NOTED: DO NOT import `mnemonic phrase` using `Account` class, use `Wallet` instead\n   * const myPrivateKey = '0xe19d05c5452598e24caad4a0d85a49146f7be089515c905ae6a19e8a578a6930'\n   * const myAccountWithMyPrivateKey = new Account(myPrivateKey)\n   * ```\n   */\n  constructor(key?: string, messenger: Messenger = defaultMessenger) {\n    this.messenger = messenger;\n    if (!key) {\n      this._new();\n    } else {\n      this._import(key);\n    }\n    this.shardID = this.messenger.currentShard || 0;\n    this.shards = new Map();\n    this.shards.set(this.shardID, {\n      address: `${this.bech32Address}${AddressSuffix}0`,\n      balance: this.balance || '0',\n      nonce: this.nonce || 0,\n    });\n  }\n\n  async toFile(password: string, options?: EncryptOptions): Promise<string> {\n    if (this.privateKey && isPrivateKey(this.privateKey)) {\n      const file = await encrypt(this.privateKey, password, options);\n      this.privateKey = file;\n      this.encrypted = true;\n      return file;\n    } else {\n      throw new Error('Encryption failed because PrivateKey is not correct');\n    }\n  }\n\n  async fromFile(keyStore: string, password: string): Promise<Account> {\n    try {\n      if (typeof password !== 'string') {\n        throw new Error('you must provide password');\n      }\n      const file: Keystore = JSON.parse(keyStore.toLowerCase());\n      const decyptedPrivateKey = await decrypt(file, password);\n      if (isPrivateKey(decyptedPrivateKey)) {\n        return this._import(decyptedPrivateKey);\n      } else {\n        throw new Error('decrypted failed');\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Get the account balance\n   *\n   * @param blockNumber by default, it's `latest`\n   *\n   * @example\n   * ```javascript\n   * account.getBalance().then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  async getBalance(blockNumber: string = 'latest'): Promise<Balance> {\n    try {\n      if (this.messenger) {\n        const balance = await this.messenger.send(\n          RPCMethod.GetBalance,\n          [this.address, blockNumber],\n          this.messenger.chainPrefix,\n          this.messenger.currentShard || 0,\n        );\n\n        const nonce = await this.messenger.send(\n          RPCMethod.GetTransactionCount,\n          [this.address, blockNumber],\n          this.messenger.chainPrefix,\n          this.messenger.currentShard || 0,\n        );\n        if (balance.isError()) {\n          throw balance.error.message;\n        }\n        if (nonce.isError()) {\n          throw nonce.error.message;\n        }\n\n        this.balance = hexToNumber(balance.result);\n        this.nonce = Number.parseInt(hexToNumber(nonce.result), 10);\n        this.shardID = this.messenger.currentShard || 0;\n      } else {\n        throw new Error('No Messenger found');\n      }\n      return {\n        balance: this.balance,\n        nonce: this.nonce,\n        shardID: this.shardID,\n      };\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * @function updateShards\n   */\n  async updateBalances(blockNumber: string = 'latest'): Promise<void> {\n    // this.messenger.setShardingProviders();\n    const shardProviders = this.messenger.shardProviders;\n    if (shardProviders.size > 1) {\n      for (const [name, val] of shardProviders) {\n        const balanceObject = await this.getShardBalance(val.shardID, blockNumber);\n        await this.shards.set(name === val.shardID ? name : val.shardID, balanceObject);\n      }\n    } else {\n      const currentShard = await this.getShardBalance(\n        this.messenger.currentShard || 0,\n        blockNumber,\n      );\n      this.shards.set(this.messenger.currentShard || 0, currentShard);\n    }\n  }\n\n  /**\n   * @function signTransaction\n   */\n  async signTransaction(\n    transaction: Transaction,\n    updateNonce: boolean = true,\n    encodeMode: string = 'rlp',\n    blockNumber: string = 'latest',\n  ): Promise<Transaction> {\n    if (!this.privateKey || !isPrivateKey(this.privateKey)) {\n      throw new Error(`${this.privateKey} is not found or not correct`);\n    }\n\n    if (updateNonce) {\n      // await this.updateBalances(blockNumber);\n      const txShardID = transaction.txParams.shardID;\n      const shardNonce = await this.getShardNonce(\n        typeof txShardID === 'string' ? Number.parseInt(txShardID, 10) : txShardID,\n        blockNumber,\n      );\n      transaction.setParams({\n        ...transaction.txParams,\n        from:\n          this.messenger.chainPrefix === ChainType.Avalanche\n            ? this.bech32Address\n            : this.checksumAddress || '0x',\n        nonce: shardNonce,\n      });\n    }\n\n    if (encodeMode === 'rlp') {\n      const [signature, rawTransaction]: [Signature, string] = RLPSign(\n        transaction,\n        this.privateKey,\n      );\n      return transaction.map((obj: any) => {\n        return {\n          ...obj,\n          signature,\n          rawTransaction,\n          from:\n            this.messenger.chainPrefix === ChainType.Avalanche\n              ? this.bech32Address\n              : this.checksumAddress || '0x',\n        };\n      });\n    } else {\n      // TODO: if we use other encode method, eg. protobuf, we should implement this\n      return transaction;\n    }\n  }\n\n  /**\n   * This function is still in development, coming soon!\n   *\n   * @param staking\n   * @param updateNonce\n   * @param encodeMode\n   * @param blockNumber\n   * @param shardID\n   */\n  async signStaking(\n    staking: StakingTransaction,\n    updateNonce: boolean = true,\n    encodeMode: string = 'rlp',\n    blockNumber: string = 'latest',\n    shardID: number = this.messenger.currentShard,\n  ): Promise<StakingTransaction> {\n    if (!this.privateKey || !isPrivateKey(this.privateKey)) {\n      throw new Error(`${this.privateKey} is not found or not correct`);\n    }\n\n    if (updateNonce) {\n      // await this.updateBalances(blockNumber);\n      const txShardID = shardID;\n      const shardNonce = await this.getShardNonce(\n        typeof txShardID === 'string' ? Number.parseInt(txShardID, 10) : txShardID,\n        blockNumber,\n      );\n      staking.setFromAddress(\n        this.messenger.chainPrefix === ChainType.Avalanche\n          ? this.bech32Address\n          : this.checksumAddress || '0x',\n      );\n      staking.setNonce(shardNonce);\n    }\n\n    if (encodeMode === 'rlp') {\n      const [signature, rawTransaction]: [Signature, string] = staking.rlpSign(this.privateKey);\n      staking.setRawTransaction(rawTransaction);\n      staking.setSignature(signature);\n      staking.setFromAddress(\n        this.messenger.chainPrefix === ChainType.Avalanche\n          ? this.bech32Address\n          : this.checksumAddress || '0x',\n      );\n\n      return staking;\n    } else {\n      // TODO: if we use other encode method, eg. protobuf, we should implement this\n      return staking;\n    }\n  }\n\n  /**\n   * @param messenger\n   *\n   * @example\n   * ```javascript\n   * // create a custom messenger\n   * const customMessenger = new Messenger(\n   *   new HttpProvider('http://localhost:9500'),\n   *   ChainType.Avalanche, // if you are connected to Avalanche's blockchain\n   *   ChainID.HmyLocal, // check if the chainId is correct\n   * )\n   *\n   * // to create an Account with random privateKey\n   * // and you can setMessenger later\n   * const randomAccount = new Account()\n   * randomAccount.setMessenger(customMessenger)\n   * ```\n   */\n  setMessenger(messenger: Messenger) {\n    this.messenger = messenger;\n  }\n\n  /**\n   * Get account address from shard ID\n   * @param shardID\n   *\n   * @example\n   * ```javascript\n   * console.log(account.getAddressFromShardID(0));\n   *\n   * > avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7-0\n   * ```\n   */\n  getAddressFromShardID(shardID: number) {\n    const shardObject = this.shards.get(shardID);\n    if (shardObject) {\n      return shardObject.address;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Get all shards' addresses from the account\n   *\n   * @example\n   * ```javascript\n   * console.log(account.getAddresses());\n   * ```\n   */\n  getAddresses(): string[] {\n    const addressArray: string[] = [];\n    for (const [name, val] of this.shards) {\n      const index: number = typeof name === 'string' ? Number.parseInt(name, 10) : name;\n      addressArray[index] = val.address;\n    }\n    return addressArray;\n  }\n\n  /**\n   * Get the specific shard's balance\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @param blockNumber by default, it's `latest`\n   *\n   * @example\n   * ```\n   * account.getShardBalance().then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  async getShardBalance(shardID: number, blockNumber: string = 'latest') {\n    const balance = await this.messenger.send(\n      RPCMethod.GetBalance,\n      [this.address, blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n\n    const nonce = await this.messenger.send(\n      RPCMethod.GetTransactionCount,\n      [this.address, blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n\n    if (balance.isError()) {\n      throw balance.error.message;\n    }\n    if (nonce.isError()) {\n      throw nonce.error.message;\n    }\n    return {\n      address: `${this.bech32Address}${AddressSuffix}${shardID}`,\n      balance: hexToNumber(balance.result),\n      nonce: Number.parseInt(hexToNumber(nonce.result), 10),\n    };\n  }\n\n  /**\n   * Get the specific shard's nonce\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @param blockNumber by default, it's `latest`\n   *\n   * @example\n   * ```\n   * account.getShardNonce().then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n  async getShardNonce(shardID: number, blockNumber: string = 'latest') {\n    const nonce = await this.messenger.send(\n      RPCMethod.GetAccountNonce,\n      [this.address, blockNumber],\n      this.messenger.chainPrefix,\n      shardID,\n    );\n    if (nonce.isError()) {\n      throw nonce.error.message;\n    }\n    return nonce.result;\n  }\n\n  /**\n   * @function _new private method create Account\n   * @return {Account} Account instance\n   * @ignore\n   */\n  private _new(): Account {\n    const prv = generatePrivateKey();\n    if (!isPrivateKey(prv)) {\n      throw new Error('key gen failed');\n    }\n    return this._import(prv);\n  }\n\n  /**\n   * @function _import private method import a private Key\n   * @param  {string} key - private key\n   * @return {Account} Account instance\n   * @ignore\n   */\n  private _import(key: string): Account {\n    if (!isPrivateKey(key)) {\n      throw new Error(`${key} is not PrivateKey`);\n    }\n    this.privateKey = add0xToString(key);\n    this.publicKey = getPubkeyFromPrivateKey(this.privateKey);\n    this.address = getAddressFromPrivateKey(this.privateKey);\n    this.shardID = this.messenger.currentShard || 0;\n    this.shards = new Map();\n    this.shards.set(this.shardID, {\n      address: `${this.bech32Address}${AddressSuffix}0`,\n      balance: this.balance || '0',\n      nonce: this.nonce || 0,\n    });\n    this.encrypted = false;\n    return this;\n  }\n}\n\n/**\n * This comment _supports_ [Markdown](https://marked.js.org/)\n */\nexport { Account };\n","/**\n * @packageDocumentation\n * @module avalanche-account\n */\n\nimport { bip39, hdkey, EncryptOptions, getAddress, generatePrivateKey } from 'avalanche-js-crypto';\nimport { Messenger } from 'avalanche-js-network';\nimport { isPrivateKey, isAddress, ChainType } from 'avalanche-js-utils';\nimport { Transaction } from 'avalanche-js-transaction';\nimport { StakingTransaction } from 'avalanche-js-staking';\nimport { Account } from './account';\nimport { defaultMessenger } from './utils';\n\nclass Wallet {\n  // static method generate Mnemonic\n  static generateMnemonic(): string {\n    return bip39.generateMnemonic();\n  }\n\n  /** @hidden */\n  messenger: Messenger;\n  /** @hidden */\n  protected defaultSigner?: string;\n  /**\n   * @hidden\n   */\n  private accountMap: Map<string, Account> = new Map();\n\n  /**\n   * get acounts addresses\n   *\n   * @return {string[]} accounts addresses\n   *\n   * @example\n   * ```javascript\n   * const wallet = new Wallet(customMessenger);\n   * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * wallet.addByPrivateKey(key_1);\n   *\n   * console.log(wallet.accounts);\n   * ```\n   */\n  get accounts(): string[] {\n    return [...this.accountMap.keys()];\n  }\n\n  /**\n   * get the signer of the account, by default, using the first account\n   *\n   * @example\n   * ```javascript\n   * const wallet = new Wallet(customMessenger);\n   * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * wallet.addByPrivateKey(key_1);\n   *\n   * console.log(wallet.signer)\n   * ```\n   */\n  get signer(): Account | undefined {\n    if (this.defaultSigner) {\n      return this.getAccount(this.defaultSigner);\n    } else if (!this.defaultSigner && this.accounts.length > 0) {\n      this.setSigner(this.accounts[0]);\n      return this.getAccount(this.accounts[0]);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @example\n   * ```\n   * const { Wallet } = require('avalanche-js-account');\n   * const { HttpProvider, Messenger } = require('avalanche-js-network');\n   * const { ChainType, ChainID } = require('avalanche-js-utils');\n   *\n   * // create a custom messenger\n   * const customMessenger = new Messenger(\n   *   new HttpProvider('http://localhost:9500'),\n   *   ChainType.Avalanche, // if you are connected to Avalanche's blockchain\n   *   ChainID.HmyLocal, // check if the chainId is correct\n   * )\n   *\n   * const wallet = new Wallet(customMessenger);\n   * ```\n   */\n  constructor(messenger: Messenger = defaultMessenger) {\n    this.messenger = messenger;\n  }\n  /**\n   * @function newMnemonic\n   * @memberof Wallet\n   * @return {string} Mnemonics\n   */\n  newMnemonic(): string {\n    return Wallet.generateMnemonic();\n  }\n\n  /**\n   * Add account using Mnemonic phrases\n   * @param  {string} phrase - Mnemonic phrase\n   * @param  {index} index - index to hdKey root\n   *\n   * @example\n   * ```javascript\n   * const mnemonic_1 = 'urge clog right example dish drill card maximum mix bachelor section select';\n   * const wallet = new Wallet(customMessenger);\n   * wallet.addByMnemonic(mnemonic_1);\n   *\n   * console.log(wallet.accounts);\n   * ```\n   */\n  addByMnemonic(phrase: string, index: number = 0) {\n    if (!this.isValidMnemonic(phrase)) {\n      throw new Error(`Invalid mnemonic phrase: ${phrase}`);\n    }\n    const seed = bip39.mnemonicToSeed(phrase);\n    const hdKey = hdkey.fromMasterSeed(seed);\n    // TODO:hdkey should apply to Avalanche's settings\n    const path = this.messenger.chainType === ChainType.Avalanche ? '1023' : '60';\n    const childKey = hdKey.derive(`m/44'/${path}'/0'/0/${index}`);\n    const privateKey = childKey.privateKey.toString('hex');\n    return this.addByPrivateKey(privateKey);\n  }\n\n  /**\n   * Add an account using privateKey\n   *\n   * @param  {string} privateKey - privateKey to add\n   * @return {Account} return added Account\n   *\n   * @example\n   * ```javascript\n   * const wallet = new Wallet(customMessenger);\n   * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * console.log(wallet.addByPrivateKey(key_1));\n   * ```\n   */\n  addByPrivateKey(privateKey: string): Account {\n    try {\n      const newAcc = Account.add(privateKey);\n      newAcc.setMessenger(this.messenger);\n      if (newAcc.address) {\n        this.accountMap.set(newAcc.address, newAcc);\n        if (!this.defaultSigner) {\n          this.setSigner(newAcc.address);\n        }\n        return newAcc;\n      } else {\n        throw new Error('add account failed');\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Add an account using privateKey\n   * @param  {string} keyStore - keystore jsonString to add\n   * @param  {string} password - password to decrypt the file\n   * @return {Account} return added Account\n   */\n  async addByKeyStore(keyStore: string, password: string): Promise<Account> {\n    try {\n      const newAcc = new Account(undefined);\n      const result = await newAcc.fromFile(keyStore, password);\n      result.setMessenger(this.messenger);\n      if (result.address) {\n        this.accountMap.set(result.address, result);\n        if (!this.defaultSigner) {\n          this.setSigner(result.address);\n        }\n        return result;\n      } else {\n        throw new Error('add account failed');\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * create a new account using Mnemonic\n   * @return {Account} {description}\n   *\n   * @example\n   * ```javascript\n   * console.log(wallet.accounts);\n   * wallet.createAccount();\n   * wallet.createAccount();\n   *\n   * console.log(wallet.accounts);\n   * ````\n   */\n  async createAccount(password?: string, options?: EncryptOptions): Promise<Account> {\n    const prv = generatePrivateKey();\n    const acc = this.addByPrivateKey(prv);\n    if (acc.address && password) {\n      const encrypted = await this.encryptAccount(acc.address, password, options);\n      return encrypted;\n    } else if (acc.address && !password) {\n      return acc;\n    } else {\n      throw new Error('create acount failed');\n    }\n  }\n\n  /**\n   * To encrypt an account that lives in the wallet.\n   * if encrypted, returns original avax, if not found, throw error\n   * @param {string} address - address in accounts\n   * @param {string} password - string that used to encrypt\n   * @param {EncryptOptions} options - encryption options\n   * @return {Promise<Account>}\n   *\n   * @example\n   * ```javascript\n   * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * wallet.addByPrivateKey(key_1);\n   * wallet.encryptAccount('avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7', '12345').then((value) => {\n   *   console.log(value);\n   * })\n   * ```\n   */\n  async encryptAccount(\n    address: string,\n    password: string,\n    options?: EncryptOptions,\n  ): Promise<Account> {\n    try {\n      const foundAcc = this.getAccount(address);\n      if (foundAcc && foundAcc.privateKey && isPrivateKey(foundAcc.privateKey)) {\n        await foundAcc.toFile(password, options);\n        return foundAcc;\n      } else if (foundAcc && foundAcc.privateKey && !isPrivateKey(foundAcc.privateKey)) {\n        return foundAcc;\n      } else {\n        throw new Error('encrypt account failed');\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * To decrypt an account that lives in the wallet,if not encrypted, return original,\n   * if not found, throw error\n   * @param {string} address - address in accounts\n   * @param {string} password - string that used to encrypt\n   * @return {Promise<Account>}\n   *\n   * @example\n   * ```javascript\n   * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * wallet.addByPrivateKey(key_1);\n   * wallet.encryptAccount('avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7', '12345')\n   * .then(() => {\n   *   wallet.decryptAccount('avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7', '12345')\n   *   .then((value) =>{\n   *      console.log(value);\n   *   });\n   * });\n   * ```\n   */\n  async decryptAccount(address: string, password: string): Promise<Account> {\n    try {\n      const foundAcc = this.getAccount(address);\n      if (foundAcc && foundAcc.privateKey && !isPrivateKey(foundAcc.privateKey)) {\n        await foundAcc.fromFile(foundAcc.privateKey, password);\n        return foundAcc;\n      } else if (foundAcc && foundAcc.privateKey && isPrivateKey(foundAcc.privateKey)) {\n        foundAcc.encrypted = false;\n        return foundAcc;\n      } else {\n        throw new Error('decrypt account failed');\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Get Account instance using address as param\n   * @param  {string} address - address hex\n   * @return {Account} Account instance which lives in Wallet\n   *\n   * @example\n   * ```\n   * const key_1 = '45e497bd45a9049bcb649016594489ac67b9f052a6cdf5cb74ee2427a60bf25e';\n   * wallet.addByPrivateKey(key_1);\n   * console.log(wallet.getAccount('avax103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7'));\n   * ```\n   */\n  getAccount(address: string): Account | undefined {\n    return this.accountMap.get(getAddress(address).basicHex);\n  }\n\n  /**\n   * @function removeAccount\n   * @memberof Wallet\n   * @description remove Account using address as param\n   * @param  {string} address: - address hex\n   */\n  removeAccount(address: string): void {\n    this.accountMap.delete(getAddress(address).basicHex);\n    if (this.defaultSigner === address) {\n      this.defaultSigner = undefined;\n    }\n  }\n\n  /**\n   * Set Customer Messenage\n   * @param messenger\n   *\n   * @example\n   * ```javascript\n   * const customMessenger = new Messenger(\n   *   new HttpProvider('https://api.s0.b.hmny.io'),\n   *   ChainType.Avalanche, // if you are connected to Avalanche's blockchain\n   *   ChainID.HmyLocal, // check if the chainId is correct\n   * )\n   * const wallet = new Wallet();\n   * wallet.setMessenger(customMessenger);\n   * console.log(wallet.messenger);\n   * ```\n   */\n  setMessenger(messenger: Messenger): void {\n    this.messenger = messenger;\n  }\n\n  /**\n   * Set signer\n   *\n   * @param address avax of the address in the accounts\n   */\n  setSigner(address: string): void {\n    if (!isAddress(address) && !this.getAccount(address)) {\n      throw new Error('could not set signer');\n    }\n    this.defaultSigner = address;\n  }\n\n  async signTransaction(\n    transaction: Transaction,\n    account: Account | undefined = this.signer,\n    // tslint:disable-next-line: no-unnecessary-initializer\n    password: string | undefined = undefined,\n    updateNonce: boolean = true,\n    encodeMode: string = 'rlp',\n    blockNumber: string = 'latest',\n  ): Promise<Transaction> {\n    const toSignWith = account || this.signer;\n    if (!toSignWith) {\n      throw new Error('no signer found or did not provide correct account');\n    }\n    if (toSignWith instanceof Account && toSignWith.encrypted && toSignWith.address) {\n      if (!password) {\n        throw new Error('must provide password to further execution');\n      }\n      try {\n        const decrypted = await this.decryptAccount(toSignWith.address, password);\n        const signed = await decrypted.signTransaction(\n          transaction,\n          updateNonce,\n          encodeMode,\n          blockNumber,\n        );\n        await this.encryptAccount(toSignWith.address, password);\n        return signed;\n      } catch (error) {\n        throw error;\n      }\n    } else if (toSignWith instanceof Account && !toSignWith.encrypted && toSignWith.address) {\n      try {\n        const signed = await toSignWith.signTransaction(\n          transaction,\n          updateNonce,\n          encodeMode,\n          blockNumber,\n        );\n        return signed;\n      } catch (error) {\n        throw error;\n      }\n    } else {\n      throw new Error('sign transaction failed');\n    }\n  }\n\n  async signStaking(\n    staking: StakingTransaction,\n    account: Account | undefined = this.signer,\n    // tslint:disable-next-line: no-unnecessary-initializer\n    password: string | undefined = undefined,\n    updateNonce: boolean = true,\n    encodeMode: string = 'rlp',\n    blockNumber: string = 'latest',\n    shardID: number = this.messenger.currentShard,\n  ): Promise<StakingTransaction> {\n    const toSignWith = account || this.signer;\n    if (!toSignWith) {\n      throw new Error('no signer found or did not provide correct account');\n    }\n    if (toSignWith instanceof Account && toSignWith.encrypted && toSignWith.address) {\n      if (!password) {\n        throw new Error('must provide password to further execution');\n      }\n      try {\n        const decrypted = await this.decryptAccount(toSignWith.address, password);\n        const signed = await decrypted.signStaking(\n          staking,\n          updateNonce,\n          encodeMode,\n          blockNumber,\n          shardID,\n        );\n        await this.encryptAccount(toSignWith.address, password);\n        return signed;\n      } catch (error) {\n        throw error;\n      }\n    } else if (toSignWith instanceof Account && !toSignWith.encrypted && toSignWith.address) {\n      try {\n        const signed = await toSignWith.signStaking(\n          staking,\n          updateNonce,\n          encodeMode,\n          blockNumber,\n          shardID,\n        );\n        return signed;\n      } catch (error) {\n        throw error;\n      }\n    } else {\n      throw new Error('sign transaction failed');\n    }\n  }\n\n  /**\n   * @function isValidMnemonic\n   * @memberof Wallet\n   * @description check if Mnemonic is valid\n   * @param  {string} phrase - Mnemonic phrase\n   * @return {boolean}\n   * @ignore\n   */\n  private isValidMnemonic(phrase: string): boolean {\n    if (phrase.trim().split(/\\s+/g).length < 12) {\n      return false;\n    }\n    return bip39.validateMnemonic(phrase);\n  }\n}\n\nexport { Wallet };\n","/**\n * @packageDocumentation\n * @module avalanche-account\n */\n\nimport { bip39, hdkey, getAddress, BN, Signature } from 'avalanche-js-crypto';\nimport {\n  HDPath,\n  // defineReadOnly,\n  isHttp,\n  isWs,\n  ChainID,\n  ChainType,\n  Unit,\n  isHex,\n  hexToNumber,\n} from 'avalanche-js-utils';\nimport { Messenger, HttpProvider, WSProvider, RPCMethod } from 'avalanche-js-network';\nimport { Transaction, TxStatus, TransasctionReceipt } from 'avalanche-js-transaction';\nimport { Account } from './account';\n\n/** @hidden */\nexport interface WalletsInterfaces {\n  [key: string]: Account;\n}\n\n/** @hidden */\nexport interface Web3TxPrams {\n  id?: string;\n  from?: string;\n  to?: string;\n  nonce?: number | string;\n  gasLimit?: BN | number | string;\n  gasPrice?: BN | number | string;\n  shardID?: number | string;\n  toShardID?: number | string;\n  data?: string;\n  value?: BN;\n  chainId?: number;\n  rawTransaction?: string;\n  unsignedRawTransaction?: string;\n  signature?: Signature | string;\n  receipt?: TransasctionReceipt;\n}\n\nexport class HDNode {\n  static isValidMnemonic(phrase: string): boolean {\n    if (phrase.trim().split(/\\s+/g).length < 12) {\n      return false;\n    }\n    return bip39.validateMnemonic(phrase);\n  }\n\n  static generateMnemonic(): string {\n    return bip39.generateMnemonic();\n  }\n\n  public provider: HttpProvider | WSProvider;\n  public gasLimit: string;\n  public gasPrice: string;\n  public messenger: Messenger;\n\n  /** @hidden */\n  private shardID: number;\n  /** @hidden */\n  private hdwallet: hdkey | undefined;\n  /** @hidden */\n  private path: string;\n  /** @hidden */\n  private index: number;\n  /** @hidden */\n  private addressCount: number;\n  /** @hidden */\n  private addresses: string[];\n  /** @hidden */\n  private wallets: WalletsInterfaces;\n\n  constructor(\n    provider: string | HttpProvider | WSProvider = 'http://localhost:9500',\n    menmonic?: string,\n    index: number = 0,\n    addressCount: number = 1,\n    shardID: number = 0,\n    chainType: ChainType = ChainType.Avalanche,\n    chainId: ChainID = ChainID.Default,\n    gasLimit = '1000000',\n    gasPrice = '2000000000',\n  ) {\n    this.provider = this.setProvider(provider);\n    this.shardID = shardID;\n    this.messenger = new Messenger(this.provider, chainType, chainId);\n    this.messenger.setDefaultShardID(this.shardID);\n    this.hdwallet = undefined;\n    this.addresses = [];\n    this.wallets = {};\n    this.path = chainType === ChainType.Avalanche ? HDPath : `m/44'/60'/0'/0/`;\n    this.index = index;\n    this.addressCount = addressCount;\n    this.getHdWallet(menmonic || HDNode.generateMnemonic());\n    this.gasLimit = gasLimit;\n    this.gasPrice = gasPrice;\n  }\n\n  normalizePrivateKeys(mnemonic: string | string[]) {\n    if (Array.isArray(mnemonic)) {\n      return mnemonic;\n    } else if (mnemonic && !mnemonic.includes(' ')) {\n      return [mnemonic];\n    } else {\n      return false;\n    }\n  }\n\n  setProvider(provider: string | HttpProvider | WSProvider) {\n    if (isHttp(provider) && typeof provider === 'string') {\n      return new HttpProvider(provider);\n    } else if (provider instanceof HttpProvider) {\n      return provider;\n    } else if (isWs(provider) && typeof provider === 'string') {\n      return new WSProvider(provider);\n    } else if (provider instanceof WSProvider) {\n      return provider;\n    } else {\n      throw new Error('provider is not recognized');\n    }\n  }\n\n  getHdWallet(mnemonic: string) {\n    if (!HDNode.isValidMnemonic(mnemonic)) {\n      throw new Error('Mnemonic invalid or undefined');\n    }\n    this.hdwallet = hdkey.fromMasterSeed(bip39.mnemonicToSeed(mnemonic));\n\n    for (let i = this.index; i < this.index + this.addressCount; i++) {\n      if (!this.hdwallet) {\n        throw new Error('hdwallet is not found');\n      }\n      const childKey = this.hdwallet.derive(`${this.path}${i}`);\n      const prv = childKey.privateKey.toString('hex');\n      const account = new Account(prv);\n      const addr = account.checksumAddress;\n      this.addresses.push(addr);\n      this.wallets[addr] = account;\n    }\n  }\n\n  // tslint:disable-next-line: ban-types\n  getAccounts(cb?: Function) {\n    if (cb) {\n      cb(null, this.addresses);\n    }\n    return this.addresses;\n  }\n  // tslint:disable-next-line: ban-types\n  getPrivateKey(address: string, cb?: Function) {\n    if (!cb) {\n      if (!this.wallets[address]) {\n        throw new Error('Account not found');\n      } else {\n        return this.wallets[address].privateKey;\n      }\n    }\n    if (!this.wallets[address]) {\n      return cb('Account not found');\n    } else {\n      cb(null, this.wallets[address].privateKey);\n    }\n  }\n  // tslint:disable-next-line: ban-types\n  async signTransaction(txParams: any | Web3TxPrams) {\n    const from: string = txParams.from ? getAddress(txParams.from).checksum : '0x';\n    const accountNonce = await this.messenger.send(\n      RPCMethod.GetAccountNonce,\n      [from, 'latest'],\n      'hmy',\n      this.shardID,\n    );\n\n    const to: string = txParams.to ? getAddress(txParams.to).checksum : '0x';\n\n    let gasLimit = new Unit('0').asWei().toWei();\n\n    if (txParams.gas !== undefined && isHex(txParams.gas)) {\n      gasLimit = new Unit(txParams.gas)\n        .asWei()\n        .toWei()\n        .lt(new Unit(this.gasLimit).asWei().toWei())\n        ? new Unit(txParams.gas).asWei().toWei()\n        : new Unit(this.gasLimit).asWei().toWei();\n    }\n    if (txParams.gasLimit !== undefined && isHex(txParams.gasLimit)) {\n      gasLimit = new Unit(txParams.gasLimit)\n        .asWei()\n        .toWei()\n        .lt(new Unit(this.gasLimit).asWei().toWei())\n        ? new Unit(txParams.gasLimit).asWei().toWei()\n        : new Unit(this.gasLimit).asWei().toWei();\n    }\n\n    let gasPrice = new Unit('0').asWei().toWei();\n    if (txParams.gasPrice !== undefined && isHex(txParams.gasPrice)) {\n      gasPrice = new Unit(txParams.gasPrice)\n        .asWei()\n        .toWei()\n        .lt(new Unit(this.gasPrice).asWei().toWei())\n        ? new Unit(txParams.gasPrice).asWei().toWei()\n        : new Unit(this.gasPrice).asWei().toWei();\n    }\n\n    const value = txParams.value !== undefined && isHex(txParams.value) ? txParams.value : '0';\n    const nonce =\n      txParams.nonce !== undefined && isHex(txParams.nonce)\n        ? Number.parseInt(hexToNumber(txParams.nonce), 10)\n        : accountNonce.result;\n    const data = txParams.data !== undefined && isHex(txParams.data) ? txParams.data : '0x';\n    const prv = this.wallets[from].privateKey;\n\n    const signerAccount = new Account(prv, this.messenger);\n\n    const tx = new Transaction(\n      {\n        ...txParams,\n        from,\n        to,\n        gasLimit,\n        gasPrice,\n        value,\n        nonce,\n        data,\n        shardID: this.shardID,\n        chainId: this.messenger.chainId,\n      },\n      this.messenger,\n      TxStatus.INTIALIZED,\n    );\n\n    const signed = await signerAccount.signTransaction(tx);\n\n    return signed.getRawTransaction();\n  }\n  getAddress(idx?: number) {\n    if (!idx) {\n      return this.addresses[0];\n    } else {\n      return this.addresses[idx];\n    }\n  }\n  getAddresses() {\n    return this.addresses;\n  }\n  addByPrivateKey(privateKey: string) {\n    const account = new Account(privateKey);\n    const addr = account.checksumAddress;\n    this.addresses.push(addr);\n    this.wallets[addr] = account;\n    return addr;\n  }\n\n  setSigner(address: string) {\n    const foundIndex = this.addresses.findIndex((value) => value === address);\n    this.addresses.slice(foundIndex, foundIndex + 1);\n    this.addresses.unshift(address);\n  }\n}\n"],"names":["defaultMessenger","Messenger","HttpProvider","ChainType","Avalanche","ChainID","HmyLocal","Account","key","messenger","_import","_new","shardID","this","currentShard","shards","Map","set","address","bech32Address","AddressSuffix","balance","nonce","add","toFile","password","options","privateKey","isPrivateKey","encrypt","file","encrypted","Error","fromFile","keyStore","JSON","parse","toLowerCase","decrypt","decyptedPrivateKey","getBalance","blockNumber","send","RPCMethod","GetBalance","chainPrefix","GetTransactionCount","isError","error","message","hexToNumber","result","Number","parseInt","updateBalances","shardProviders","size","name","val","getShardBalance","balanceObject","signTransaction","transaction","updateNonce","encodeMode","txShardID","txParams","getShardNonce","setParams","from","checksumAddress","RLPSign","signature","rawTransaction","map","obj","_this","signStaking","staking","shardNonce","setFromAddress","setNonce","rlpSign","setRawTransaction","setSignature","setMessenger","getAddressFromShardID","shardObject","get","getAddresses","addressArray","GetAccountNonce","prv","generatePrivateKey","add0xToString","publicKey","getPubkeyFromPrivateKey","getAddressFromPrivateKey","getAddress","checksum","bech32","bech32TestNet","Wallet","generateMnemonic","bip39","newMnemonic","addByMnemonic","phrase","index","isValidMnemonic","seed","mnemonicToSeed","hdkey","fromMasterSeed","derive","chainType","toString","addByPrivateKey","newAcc","accountMap","defaultSigner","setSigner","addByKeyStore","undefined","createAccount","acc","encryptAccount","foundAcc","getAccount","decryptAccount","basicHex","removeAccount","isAddress","account","signer","toSignWith","decrypted","signed","trim","split","length","validateMnemonic","keys","accounts","HDNode","provider","menmonic","addressCount","chainId","gasLimit","gasPrice","Default","setProvider","setDefaultShardID","hdwallet","addresses","wallets","path","HDPath","getHdWallet","normalizePrivateKeys","mnemonic","Array","isArray","includes","isHttp","isWs","WSProvider","i","addr","push","getAccounts","cb","getPrivateKey","accountNonce","to","Unit","asWei","toWei","gas","isHex","lt","value","data","signerAccount","tx","Transaction","TxStatus","INTIALIZED","getRawTransaction","idx","foundIndex","findIndex","slice","unshift"],"mappings":"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"}